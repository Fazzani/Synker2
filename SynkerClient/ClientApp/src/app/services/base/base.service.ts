import { Injectable, Inject, Optional } from '@angular/core';
import { HttpClient } from '@angular/common/http';

// All the RxJS stuff we need
import { Observable } from 'rxjs/Observable';
import { map, catchError } from 'rxjs/operators';
import { ElasticResponse, SimpleQueryElastic } from "../../types/elasticQuery.type";
import * as variables from '../../variables';

@Injectable()
export class BaseService {

    protected FullBaseUrl: string = `${variables.BASE_API_URL}${this.BaseUrl}`;

    constructor(protected http: HttpClient, protected BaseUrl: string) { }

  search<T>(query: SimpleQueryElastic): Observable<ElasticResponse<T>> {
    return this.http.post(`${this.FullBaseUrl}/_searchstring`, query).map(this.handleSuccess).catch(this.handleError);
    }

    simpleSearch<T>(query: string, indexName: string): Observable<ElasticResponse<T>> {
      return this.http.post(`${this.FullBaseUrl}/_searchstring`, <SimpleQueryElastic>{ From: 0, Size: 30, IndexName: indexName, Query: query })
        .map(this.handleSuccess)
        .catch(this.handleError);
    }

    delete(id: string): Observable<number> {
      return this.http.delete(`${this.FullBaseUrl}/${id}`)
        .map(this.handleSuccess)
        .catch(this.handleError);
    }

  handleSuccess = (response: Response | any) => { // the return here is any, as you dont know how do the POJO(s) generated by response.json() look like
    let body;

    if (response.text()) {
      body = response.json();
    }

    return body || {};
  };

    protected handleError(error: Response | any) {
        let errorMessage: string;

        errorMessage = error.message ? error.message : error.toString();

        // In real world application, call to log error to remote server
        // logError(error);

        // This returns another Observable for the observer to subscribe to
        return Observable.throw(errorMessage);
    }

    // This method parses the data to JSON
    protected parseData(res: Response) {
        return res.json() || [];
    }

    /**
     * Is Json 
     * @param {string} str
     * @returns
     */
    protected IsJsonString(str: string): boolean {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        return true;
    }
}
